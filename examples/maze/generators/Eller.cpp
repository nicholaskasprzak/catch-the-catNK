#include "Eller.h"
#include "../World.h"
#include "Random.h"
#include <climits>
#include <algorithm>

bool Eller::Step(World* world)
{
	int worldSize = world->GetSize();
	currentRow = -worldSize / 2 + currentStep;

	populate(world);

	// Good chance that this is wrong. The example is hard
	// to follow considering how different Ruby is structured.
	
	// My guess is that connectedSets keeps track of all nodes
	// that connect to each other for the current row.
	// 
	// connectedSet keeps track of the current set being built,
	// but is overwritten when a new set must be formed. This
	// is fine as all sets get saved in connectedSets in the end
	// so they can be processed later.
	std::vector<std::vector<Point2D>> connectedSets;
	std::vector<Point2D> connectedSet;

	for (int i = -worldSize / 2; i < worldSize / 2 - 1; i++)
	{
		Point2D currentNode = Point2D(i, currentRow);
		Point2D nextNode = Point2D(i + 1, currentRow);

		// If the two nodes are not joined by the same set, or are randomly chosen to not be connected(?), start a new connectedSet
		// from the next node.
		if (sameSet(currentNode, nextNode) || (!finished && Random::Range(0, 2) > 0))
		{
			connectedSets.push_back(connectedSet);
			connectedSet.clear();
			connectedSet.push_back(nextNode);
		}

		// Otherwise, merge the two nodes and add to the current connectedSet
		else
		{
			merge(currentNode, nextNode);
			connectedSet.push_back(nextNode);
		}
	}

	connectedSets.push_back(connectedSet);

	// Keeps track of nodes that are moved down from
	// randomly from the current row's sets.
	std::vector<Point2D> verticals;

	// How do I keep track of the nodes below the selected verticals though?

	// In this part of the code, are sets and nodes supposed
	// to be cleared? A new state class is created in the example,
	// which I assume means sets and nodes have been erased? The
	// example copies some of the old nodes over at random that
	// will be used to create some verticals, which are also added
	// to the new row in the same set.
	if (!finished)
	{
		std::map<int, std::vector<std::pair<int, int>>> setsCopy = sets;
		std::map<int, std::map<int, int>> nodesCopy = nodes;

		sets.erase(sets.begin(), sets.end());
		nodes.erase(nodes.begin(), nodes.end());

		// For each set of the current row
		for (auto currentSet : setsCopy)
		{
			// Randomly choose some nodes to create verticals from
			// The randomization method the uses uses shuffles
			// the points in the current node randomly, then
			// chooses a random range of elements to move to
			// pointsToConnect.
			std::vector<Point2D> pointsToConnect;

			std::vector<std::pair<int, int>> setCopy = currentSet.second;
			std::shuffle(std::begin(setCopy), std::end(setCopy), std::default_random_engine());
			int randomEnd = Random::Range(0, setCopy.size());

			for (int i = 0; i < randomEnd; i++)
			{
				Point2D itemPoint2D = Point2D(setCopy[i].first, setCopy[i].second); // was -1
				pointsToConnect.push_back(itemPoint2D);
			}

			// Move those nodes to the verticals vector
			for (int i = 0; i < pointsToConnect.size(); i++)
			{
				verticals.push_back(pointsToConnect[i]);
			}

			// Add each of the selected nodes to the (now empty?) set and node maps with add
			for (auto point : pointsToConnect)
			{
				add(point, currentSet.first);
			}
		}
	}

	// Go through each connected set and display
	// the paths generated by them.
	for (auto set : connectedSets)
	{
		for (int i = 0; i < set.size(); i++)
		{
			Point2D node = set[i];
			bool up = false;
			bool down = false;
			bool left = false;
			bool right = false;

			// This is really ugly and overly expensive for what it does.
			// Not sure how to implement it better though.
			// Check if node is on any of the world borders
			if (node.x == -worldSize / 2)
			{
				left = true;
			}

			else if (node.x == worldSize / 2)
			{
				right = true;
			}

			if (node.y == -worldSize / 2)
			{
				up = true;
			}

			else if (node.y == worldSize / 2)
			{
				down = true;
			}

			// Check left or right for its connected nodes
			if (right == false)
			{
				Point2D rightNode = Point2D(node.x + 1, node.y);
				right = true;

				for (int i = 0; i < set.size(); i++)
				{
					if (set[i] == rightNode)
					{
						right = false;
						break;
					}
				}
			}

			if (left == false)
			{
				Point2D leftNode = Point2D(node.x - 1, node.y);
				left = true;

				for (int i = 0; i < set.size(); i++)
				{
					if (set[i] == leftNode)
					{
						left = false;
						break;
					}
				}
			}

			// Check if the node is to be expanded vertically
			if (down == false)
			{
				down = true;

				for (int i = 0; i < verticals.size(); i++)
				{
					if (verticals[i] == node)
					{
						down = false;
					}
				}
			}

			if (previousVerticals.size() != 0)
			{
				up = true;

				for (int i = 0; i < previousVerticals.size(); i++)
				{
					std::pair<int, int> upOne = std::make_pair(node.x, node.y - 1);

					if (upOne == previousVerticals[i])
					{
						up = false;
					}
				}
			}

			Node newNode = Node(up, right, down, left);
			world->SetNode(node, newNode);
			world->SetNodeColor(node, Color::Black);
		}
	}

	previousVerticals.clear();
	for (int i = 0; i < verticals.size(); i++)
	{
		previousVerticals.push_back(std::make_pair(verticals[i].x, verticals[i].y));
	}

	currentStep++;
	return true;
}

void Eller::Clear(World* world)
{
	return;
}

// Merges the sets of the two given nodes
void Eller::merge(Point2D mergingNode, Point2D targetNode)
{
	// Ends early if the nodes happen to already be in the same set
	if (sameSet(mergingNode, targetNode))
	{
		return;
	}

	std::pair<int, int> mergeLocation = std::make_pair(mergingNode.x, mergingNode.y);
	std::pair<int, int> targetLocation = std::make_pair(targetNode.x, targetNode.y);
	
	int mergingSet = nodes[mergeLocation.first][mergeLocation.second];
	int targetSet = nodes[targetLocation.first][targetLocation.second];

	// For some reason, the sameSet check didn't always work and lead to crashes.
	// This check exists now to prevent that.
	if (mergingSet == targetSet)
	{
		return;
	}

	// Move all nodes from the merged set to the target set
	// and update their status in nodes to reflect their new
	// location in the target set
	for (int i = 0; i < sets[mergingSet].size(); i++)
	{
		sets[targetSet].push_back(sets[mergingSet][i]);
		nodes[sets[mergingSet][i].first][sets[mergingSet][i].second] = targetSet;
	}
	
	// Delete the merged set as it no longer exists as its own set
	sets.erase(mergingSet);

	return;
}

// Adds node to the target set and keeps track of its location in that set
void Eller::add(Point2D node, int set)
{
	std::pair<int, int> location = std::make_pair(node.x, node.y);
	sets[set].push_back(location);
	nodes[location.first][location.second] = set;
}

// Compares two nodes to see if they're in the same set
bool Eller::sameSet(Point2D node1, Point2D node2)
{
	return node1 == node2;
}

// Populates the nodes of the current row if they don't
// already have a set assigned to them. This ensures that
// all nodes in a row are factored into the generation process.
// Really inefficient but I can't think of a better way to do it currently.
void Eller::populate(World* world)
{
	int worldSize = world->GetSize();
	int currentRow = -worldSize/2 + currentStep;
	int emptySetVal = 1;

	for (int i = -worldSize/2; i < worldSize/2; i++)
	{
		std::pair<int, int> currentNode = std::make_pair(i, currentRow);

		// Check if the node already has an entry
		if (nodes.find(currentNode.first) == nodes.end())
		{
			if (nodes[currentNode.first].find(currentNode.second) == nodes[currentNode.first].end())
			{
				// Try to find a set number that hasn't been used
				while (sets.find(emptySetVal) != sets.end())
				{
					emptySetVal++;
				}

				std::vector<std::pair<int, int>> tempVector;
				tempVector.push_back(currentNode);

				sets.insert(std::make_pair(emptySetVal, tempVector));
				//nodes.insert(std::make_pair(currentNode, emptySetVal));
				nodes[currentNode.first].insert(std::make_pair(currentNode.second, emptySetVal));
			}
		}
	}
}